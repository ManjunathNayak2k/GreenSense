name: GreenSense

on:
  pull_request:
    branches:
        - main
    types:
        - opened
        - synchronize

jobs:
  GreenSense:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Get Updated Code
        env: 
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }} 
        id: process-files
        uses: actions/github-script@v5
        with:
          script: |
            const https = require('https');
            const fs = require('fs');
        
            const { owner, repo, number } = context.issue;
        
            const prompt = `
            Your task is to optimize the provided code. Improve its speed and time complexity. Improve its algorithmic efficiency. Some optimizations may include connection pooling, inbuilt functions, parallel processing. The response should strictly follow this structure:

            First, begin with the string [CODE_START], followed by the optimized code, and then [CODE_END]. After that, begin with [EXPLANATION_START]. For each function you've optimized, start the explanation with the function name followed by its description of optimization. Please make sure each function's explanation is on a new line. Do not include the time complexities of the original or optimized code in the explanation section. Conclude with [EXPLANATION_END].
            
            For example:
            [EXPLANATION_START]
            function1(): Use the list() function with range() to create the large list efficiently.
            function2(): Use the math.factorial() function to calculate the factorial of a number.
            function3(): Use a loop to calculate the Fibonacci sequence iteratively, which is more efficient.
            [EXPLANATION_END]`

            
            function get_function_explanations(explanation) {
              const functionPattern = /(\w+)\(\):\s*([\s\S]*?(?=\w+\(\):|$))/g;

              let match;
              let explanations = [];
              
              while ((match = functionPattern.exec(explanation)) !== null) {
                  const functionName = match[1];
                  const functionExplanation = match[2].trim(); // Trimming to remove any trailing or leading whitespace
                  explanations.push({ [functionName]: functionExplanation });
              }
              return explanations;
            }

            function findFunctionLineNumbers(codeStr, explanationsList) {
                const lines = codeStr.split('\n');
                const updatedExplanationsList = {};

                explanationsList.forEach(explanationObj => {
                    const func = Object.keys(explanationObj)[0]; // This retrieves the function name from the object
                    const explanation = Object.values(explanationObj)[0];
                    const pattern = new RegExp(`def ${func}\\(`);
                    
                    for (let i = 0; i < lines.length; i++) {
                        if (pattern.test(lines[i])) {
                            updatedExplanationsList[func] = [i + 1, explanation];
                            break;  // exit the loop once the function is found
                        }
                    }
                });

                return updatedExplanationsList;
            }

            async function makeOpenAIRequest(fileContent) {
                return new Promise((resolve, reject) => {
                    const requestData = {
                        model: "gpt-3.5-turbo",
                        temperature: 0.1,
                        messages: [
                            {
                              "role": "system",
                              "content": prompt
                            },
                            {
                              "role": "user",
                              "content": fileContent
                            }
                        ]
                    };
        
                    const options = {
                        hostname: 'api.openai.com',
                        path: '/v1/chat/completions',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + process.env.OPENAI_API_KEY,
                            'Content-Length': Buffer.byteLength(JSON.stringify(requestData))
                        }
                    };
        
                    const req = https.request(options, res => {
                        let responseBody = '';
        
                        res.on('data', chunk => {
                            responseBody += chunk;
                        });
        
                        res.on('end', () => {
                            resolve(JSON.parse(responseBody));
                        });
                    });
        
                    req.on('error', error => {
                        reject(error);
                    });
        
                    req.write(JSON.stringify(requestData));
                    req.end();
                });
            }
        
            // Get the list of files changed in the PR
            const { data: files } = await github.rest.pulls.listFiles({
                owner, repo, pull_number: number
            });
        
            const updatedFiles = [];
        
            for (const file of files) {
                const fileContent = fs.readFileSync(file.filename, 'utf8');
        
                try {
                    const response = await makeOpenAIRequest(fileContent);

                    // GPT response
                    const chatResponse = response.choices[0].message.content;
        
                    const code_regex = /\[CODE_START\]([\s\S]*?)\[CODE_END\]/;
                    const explanation_regex = /\[EXPLANATION_START\]([\s\S]*?)\[EXPLANATION_END\]/;
        
                    const codeMatch = chatResponse.match(code_regex);
                    const explanationMatch = chatResponse.match(explanation_regex);
        
                    let updatedCode = fileContent;
                    let explanation = 'No explanation';
        
                    if (codeMatch && codeMatch[1]) {
                        updatedCode = codeMatch[1];
                    } 
        
                    if (explanationMatch && explanationMatch[1]) {
                        explanation = explanationMatch[1];
                    } 
        
                    // Write new content to file
                    fs.writeFileSync(file.filename, updatedCode, 'utf8');
                    
                    let explanations = get_function_explanations(explanation);
                    let explanations_with_line_numbers = findFunctionLineNumbers(updatedCode, explanations)

                    updatedFiles.push({ path: file.filename, explanation: explanations_with_line_numbers });
                } catch (error) {
                    console.error("Error with OpenAI request:", error);
                }
            }
            console.log(JSON.stringify(updatedFiles))
            core.exportVariable('updatedFiles', updatedFiles);

      - name: Commit and Push to New Branch to New Branch
        run: |
            # Extract the source branch name
            SOURCE_BRANCH=$GITHUB_HEAD_REF
            NEW_BRANCH="Green-$SOURCE_BRANCH"

            # Create and switch to the new branch
            git checkout -b $NEW_BRANCH

            # Set git user details
            git config user.name "GitHub Action"
            git config user.email "action@github.com"

            # Add and commit changes
            git add -A
            git commit -m "Replaced old code with new code from API" || echo "No changes to commit"

            # Use GITHUB_TOKEN for authentication
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}

            # Push changes
            git push --set-upstream origin $NEW_BRANCH || echo "No changes to push"
    
      - name: Create PR and Comment
        uses: actions/github-script@v5
        with:
          script: |
            const sourceBranch = context.payload.pull_request.head.ref; 
            const optimisedBranch = `Green-${sourceBranch}`;

            updatedFiles=JSON.parse(process.env.updatedFiles)

            // Combine explanations and create a comment on the new PR
            const explanations = updatedFiles.map(file => `File: ${file.path}\nExplanation: ${file.explanation}`).join("\n\n");

            // Check if a PR already exists for the branch
            const existingPRs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${optimisedBranch}`
            });

            let prNumber = null
            // If no PRs found for the branch, create one
            if (existingPRs.data.length === 0) {
              // Create a PR
              pr = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `GreenSense optimisations for ${sourceBranch}`,
                  head: optimisedBranch, // "optimised-testbranch"
                  base: sourceBranch, // "testbranch"
                  body: explanations
              });
              prNumber = pr.data.number
            }
            else {
              prNumber = existingPRs.data[0].number;
            }
          
            // Flatten the data structure to get a list of files with their corresponding line numbers and explanations
            const flattenedComments = [];
            
            for (let filepath in updatedFiles) {
              let functions = updatedFiles[filepath].explanation;
              for (let func in functions) {
                  let data = functions[func];
                  flattenedComments.push({
                      path: filepath,
                      position: parseInt(data[0], 10), // Convert to integer if it's a string
                      body: data[1] // This is the explanation
                  });
              }
            }
            
            // Create review comments for each file
            await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,  
                event: "COMMENT",  
                comments: flattenedComments
            });
            